<!doctype html>
{% load static %}
<html>
<head>
  <meta charset="utf-8">
  <title>Image Compressor — SVD & CNN</title>
  <link rel="stylesheet" href="{% static 'compressor/css/styles.css' %}">
  <style>
    /* tiny spinner + layout tweak */
    .spinner{display:none;width:28px;height:28px;border-radius:50%;border:4px solid rgba(0,0,0,.08);border-top-color:#111;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .preview-row{display:flex;gap:18px;align-items:flex-start}
    .preview-card{flex:1}
    .muted{color:#6b7280;font-size:13px}
    .slider-row{display:flex;gap:12px;align-items:center;margin-top:8px}
    .cnn-field{display:none}
    .method-section{border:1px solid #e5e7eb;padding:12px;margin:12px 0;border-radius:6px}
  </style>
</head>
<body>
  <main class="container">
    <h1>Image Compressor — SVD & CNN Deep Learning</h1>

    <form id="uploadForm" method="post" enctype="multipart/form-data" action="{% url 'compressor:compress' %}">
      {% csrf_token %}
      <p>
        {{ form.image.label_tag }}
        {{ form.image }}
      </p>
      
      <div class="method-section">
        <p>
          {{ form.method.label_tag }}
          {{ form.method }}
        </p>
      </div>
      
      <!-- SVD Parameters -->
      <div id="svd-params" class="method-section">
        <h3 style="margin-top:0">SVD Parameters</h3>
        <!-- hidden input to carry k value from the slider to server -->
        <input type="hidden" name="k" id="kInput" value="{{ form.initial.k|default:50 }}">

        <div class="slider-row">
          <label for="kRange">k</label>
          <input id="kRange" type="range" min="1" max="200" value="{{ form.initial.k|default:50 }}">
          <output id="kValue">50</output>
          <div class="spinner" id="liveSpinner"></div>
        </div>

        <div style="margin-top:8px">
          {{ form.maintain_quality }} {{ form.maintain_quality.label_tag }}
          <span style="margin-left:12px">{{ form.target_psnr.label_tag }} {{ form.target_psnr }}</span>
        </div>
      </div>
      
      <!-- CNN Parameters -->
      <div id="cnn-params" class="method-section" style="display:none">
        <h3 style="margin-top:0">CNN Parameters</h3>
        <p>
          {{ form.latent_dim.label_tag }}
          {{ form.latent_dim }}
        </p>
        <p>
          {{ form.model_type.label_tag }}
          {{ form.model_type }}
        </p>
        <p class="muted">⚠️ Note: CNN requires PyTorch. If no trained model is found, results may be poor until you train a model.</p>
      </div>
      
      <!-- Common Parameters -->
      <div class="method-section">
        <h3 style="margin-top:0">Common Options</h3>
        <div class="slider-row">
          {{ form.size.label_tag }}
          {{ form.size }}
        </div>

        <div style="margin-top:8px">
          {{ form.sharpen }} {{ form.sharpen.label_tag }}
        </div>
      </div>

      <button type="submit" class="btn">Compress (save)</button>
    </form>

    <p class="muted">For SVD: Drag the slider to preview compression. For CNN: Click compress to see results.</p>

    <section class="preview-row" style="margin-top:18px">
      <div class="preview-card">
        <h4>Original</h4>
        <img id="origPreview" src="" alt="original preview" class="preview" style="display:none">
        <p id="origMsg" class="muted">No file chosen</p>
        <p style="margin-top:8px">
          <a id="downloadOrig" class="btn secondary" style="display:none" download>Download original</a>
        </p>
      </div>

      <div class="preview-card">
        <h4>Live compressed preview</h4>
        <img id="compPreview" src="" alt="compressed preview" class="preview" style="display:none">
        <p id="compMsg" class="muted">No preview</p>
        <p style="margin-top:8px">
          <a id="downloadComp" class="btn" style="display:none;margin-right:8px" download>Download preview</a>
        </p>
      </div>
    </section>
  </main>

  <script>
    // Method switching
    function toggleMethodFields() {
      const methodField = document.getElementById('methodSelect') || document.getElementById('id_method');
      if (!methodField) return;
      const method = methodField.value;
      const svdParams = document.getElementById('svd-params');
      const cnnParams = document.getElementById('cnn-params');
      
      if (method === 'cnn') {
        svdParams.style.display = 'none';
        cnnParams.style.display = 'block';
      } else {
        svdParams.style.display = 'block';
        cnnParams.style.display = 'none';
      }
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
      toggleMethodFields();
      const methodSelect = document.getElementById('methodSelect') || document.getElementById('id_method');
      if (methodSelect) {
        methodSelect.addEventListener('change', toggleMethodFields);
      }
    });
    
    // Helpers: CSRF
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
    const csrftoken = getCookie('csrftoken');

  const fileInput = document.querySelector('input[type=file]');
    const kRange = document.getElementById('kRange');
    const kValue = document.getElementById('kValue');
    const origPreview = document.getElementById('origPreview');
    const compPreview = document.getElementById('compPreview');
    const origMsg = document.getElementById('origMsg');
    const compMsg = document.getElementById('compMsg');
    const spinner = document.getElementById('liveSpinner');
  const downloadOrig = document.getElementById('downloadOrig');
  const downloadComp = document.getElementById('downloadComp');

    let debounceTimer = null;

    // show chosen original locally (file -> objectURL) and enable download
    let origObjectUrl = null;
    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file) {
        if (origObjectUrl) URL.revokeObjectURL(origObjectUrl);
        origObjectUrl = null;
        origPreview.style.display = 'none';
        origMsg.textContent = 'No file chosen';
        downloadOrig.style.display = 'none';
        return;
      }
      if (origObjectUrl) URL.revokeObjectURL(origObjectUrl);
      origObjectUrl = URL.createObjectURL(file);
      origPreview.src = origObjectUrl;
      origPreview.style.display = '';
      // try to also show image dimensions
      const imgForSize = new Image();
      imgForSize.onload = () => {
        origMsg.textContent = `${file.name} — ${file.size} bytes — ${imgForSize.naturalWidth}x${imgForSize.naturalHeight}px`;
        origPreview.dataset.origWidth = imgForSize.naturalWidth;
        origPreview.dataset.origHeight = imgForSize.naturalHeight;
      };
      imgForSize.src = origObjectUrl;
      // enable original download using objectURL (set filename)
      downloadOrig.href = origObjectUrl;
      downloadOrig.download = file.name;
      downloadOrig.style.display = '';
      triggerPreview(); // auto preview when user picks file
    });

    const kInput = document.getElementById('kInput');
    const sizeSelect = document.getElementById('sizeSelect');
    const methodSelect = document.getElementById('methodSelect') || document.getElementById('id_method');
    const latentDimInput = document.getElementById('id_latent_dim');
    const modelTypeSelect = document.getElementById('id_model_type');
    const maintainQualityInput = document.getElementById('id_maintain_quality');
    const targetPsnrInput = document.getElementById('id_target_psnr');
    const sharpenInput = document.getElementById('id_sharpen');

    kRange.addEventListener('input', () => {
      kValue.value = kRange.value;
      kInput.value = kRange.value; // sync hidden input so full form submit has correct k
      // live preview but debounce to avoid too many uploads
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(triggerPreview, 400);
    });

    function triggerPreview() {
      const file = fileInput.files[0];
      if (!file) {
        compMsg.textContent = 'Choose an image file first';
        return;
      }

  const formData = new FormData();
  formData.append('image', file);
  formData.append('method', methodSelect ? methodSelect.value : 'svd');
  formData.append('k', kRange.value);
  formData.append('size', sizeSelect.value);
  formData.append('latent_dim', latentDimInput ? latentDimInput.value : '64');
  formData.append('model_type', modelTypeSelect ? modelTypeSelect.value : 'standard');
  formData.append('target_psnr', targetPsnrInput ? targetPsnrInput.value : '30');
  if (maintainQualityInput && maintainQualityInput.checked) {
    formData.append('maintain_quality', 'on');
  }
  if (sharpenInput && sharpenInput.checked) {
    formData.append('sharpen', 'on');
  }

      spinner.style.display = 'inline-block';
      compMsg.textContent = 'Processing...';

      fetch("{% url 'compressor:preview' %}", {
        method: 'POST',
        headers: {'X-CSRFToken': csrftoken},
        body: formData
      }).then(r => r.json())
        .then(data => {
          spinner.style.display = 'none';
          if (data.error) {
            compMsg.textContent = 'Error: ' + (data.error || 'unknown');
            return;
          }
          compPreview.src = data.comp_url + (data.comp_url.indexOf('?') === -1 ? ('?t=' + Date.now()) : ('&t=' + Date.now()));
          compPreview.style.display = '';
          // show download link for compressed preview
          downloadComp.href = data.comp_url;
          // try to infer filename from URL
          try {
            const parts = data.comp_url.split('/');
            downloadComp.download = parts[parts.length - 1] || `compressed_k${kRange.value}.png`;
          } catch (e) {
            downloadComp.download = `compressed_k${kRange.value}`;
          }
          downloadComp.style.display = '';
          const sizeLabel = sizeSelect.options[sizeSelect.selectedIndex].text || (`${Math.round(parseFloat(sizeSelect.value)*100)}%`);
          compMsg.innerHTML = `PSNR: ${data.psnr} dB — size ${data.comp_size} bytes (orig ${data.orig_size} bytes) — output ${sizeLabel} — ${data.width}x${data.height}px`;
        })
        .catch(err => {
          spinner.style.display = 'none';
          compMsg.textContent = 'Network error';
          console.error(err);
        });
    }
  </script>
</body>
</html>
